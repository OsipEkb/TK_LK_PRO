import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/highcharts/highcharts-3d.js
var require_highcharts_3d = __commonJS({
  "node_modules/highcharts/highcharts-3d.js"(exports, module) {
    !/**
    * Highcharts JS v12.5.0 (2026-01-12)
    * @module highcharts/highcharts-3d
    * @requires highcharts
    *
    * 3D features for Highcharts JS
    *
    * (c) 2009-2026 Highsoft AS
    *
    * A commercial license may be required depending on use.
    * See www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(t._Highcharts, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.RendererRegistry, t._Highcharts.Series, t._Highcharts.StackItem, t._Highcharts.Axis, t._Highcharts.Series.types.scatter) : "function" == typeof define && define.amd ? define("highcharts/highcharts-3d", ["highcharts/highcharts"], function(t2) {
        return e(t2, t2.Color, t2.SeriesRegistry, t2.RendererRegistry, t2.Series, t2.StackItem, t2.Axis, t2.Series, ["types"], ["scatter"]);
      }) : "object" == typeof exports ? exports["highcharts/highcharts-3d"] = e(t._Highcharts, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.RendererRegistry, t._Highcharts.Series, t._Highcharts.StackItem, t._Highcharts.Axis, t._Highcharts.Series.types.scatter) : t.Highcharts = e(t.Highcharts, t.Highcharts.Color, t.Highcharts.SeriesRegistry, t.Highcharts.RendererRegistry, t.Highcharts.Series, t.Highcharts.StackItem, t.Highcharts.Axis, t.Highcharts.Series.types.scatter);
    }("u" < typeof window ? exports : window, (t, e, i, s, a, o, r, h) => (() => {
      "use strict";
      var n, l, p = { 184: (t10) => {
        t10.exports = o;
      }, 512: (t10) => {
        t10.exports = i;
      }, 532: (t10) => {
        t10.exports = r;
      }, 608: (t10) => {
        t10.exports = s;
      }, 620: (t10) => {
        t10.exports = e;
      }, 632: (t10) => {
        t10.exports = h;
      }, 820: (t10) => {
        t10.exports = a;
      }, 944: (e2) => {
        e2.exports = t;
      } }, c = {};
      function d(t10) {
        var e2 = c[t10];
        if (void 0 !== e2) return e2.exports;
        var i2 = c[t10] = { exports: {} };
        return p[t10](i2, i2.exports, d), i2.exports;
      }
      d.n = (t10) => {
        var e2 = t10 && t10.__esModule ? () => t10.default : () => t10;
        return d.d(e2, { a: e2 }), e2;
      }, d.d = (t10, e2) => {
        for (var i2 in e2) d.o(e2, i2) && !d.o(t10, i2) && Object.defineProperty(t10, i2, { enumerable: true, get: e2[i2] });
      }, d.o = (t10, e2) => Object.prototype.hasOwnProperty.call(t10, e2);
      var x = {};
      d.d(x, { default: () => eZ });
      var y = d(944), f = d.n(y), u = d(620), z = d.n(u);
      let { deg2rad: g } = f(), { pick: b } = f();
      function m(t10, e2, i2, s2) {
        let a2 = e2.options.chart.options3d, o2 = b(s2, !!i2 && e2.inverted), r2 = { x: e2.plotWidth / 2, y: e2.plotHeight / 2, z: a2.depth / 2, vd: b(a2.depth, 1) * b(a2.viewDistance, 0) }, h2 = e2.scale3d || 1, n2 = g * a2.beta * (o2 ? -1 : 1), l2 = g * a2.alpha * (o2 ? -1 : 1), p2 = { cosA: Math.cos(l2), cosB: Math.cos(-n2), sinA: Math.sin(l2), sinB: Math.sin(-n2) };
        return i2 || (r2.x += e2.plotLeft, r2.y += e2.plotTop), t10.map(function(t11) {
          var e3, i3, s3;
          let a3 = (e3 = (o2 ? t11.y : t11.x) - r2.x, i3 = (o2 ? t11.x : t11.y) - r2.y, s3 = (t11.z || 0) - r2.z, { x: p2.cosB * e3 - p2.sinB * s3, y: -p2.sinA * p2.sinB * e3 + p2.cosA * i3 - p2.cosB * p2.sinA * s3, z: p2.cosA * p2.sinB * e3 + p2.sinA * i3 + p2.cosA * p2.cosB * s3 }), n3 = v(a3, r2, r2.vd);
          return n3.x = n3.x * h2 + r2.x, n3.y = n3.y * h2 + r2.y, n3.z = a3.z * h2 + r2.z, { x: o2 ? n3.y : n3.x, y: o2 ? n3.x : n3.y, z: n3.z };
        });
      }
      function v(t10, e2, i2) {
        let s2 = i2 > 0 && i2 < 1 / 0 ? i2 / (t10.z + e2.z + i2) : 1;
        return { x: t10.x * s2, y: t10.y * s2 };
      }
      function M(t10) {
        let e2 = 0, i2, s2;
        for (i2 = 0; i2 < t10.length; i2++) s2 = (i2 + 1) % t10.length, e2 += t10[i2].x * t10[s2].y - t10[s2].x * t10[i2].y;
        return e2 / 2;
      }
      let A = { perspective: m, perspective3D: v, pointCameraDistance: function(t10, e2) {
        let i2 = e2.options.chart.options3d, s2 = { x: e2.plotWidth / 2, y: e2.plotHeight / 2, z: b(i2.depth, 1) * b(i2.viewDistance, 0) + i2.depth };
        return Math.sqrt(Math.pow(s2.x - b(t10.plotX, t10.x), 2) + Math.pow(s2.y - b(t10.plotY, t10.y), 2) + Math.pow(s2.z - b(t10.plotZ, t10.z), 2));
      }, shapeArea: M, shapeArea3D: function(t10, e2, i2) {
        return M(m(t10, e2, i2));
      } }, { parse: P } = z(), { defaultOptions: k } = f(), { perspective: S, shapeArea3D: w } = A, { addEvent: D, isArray: L, merge: I, pick: T, wrap: X } = f();
      !function(t10) {
        function e2(t11) {
          this.is3d() && "scatter" === t11.options.type && (t11.options.type = "scatter3d");
        }
        function i2() {
          if (this.chart3d && this.is3d()) {
            let t11 = this.renderer, e3 = this.options.chart.options3d, i3 = this.chart3d.get3dFrame(), s3 = this.plotLeft, a3 = this.plotLeft + this.plotWidth, o3 = this.plotTop, r3 = this.plotTop + this.plotHeight, h3 = e3.depth, n3 = s3 - (i3.left.visible ? i3.left.size : 0), l3 = a3 + (i3.right.visible ? i3.right.size : 0), p3 = o3 - (i3.top.visible ? i3.top.size : 0), c3 = r3 + (i3.bottom.visible ? i3.bottom.size : 0), d3 = 0 - (i3.front.visible ? i3.front.size : 0), x2 = h3 + (i3.back.visible ? i3.back.size : 0), y2 = this.hasRendered ? "animate" : "attr";
            this.chart3d.frame3d = i3, this.frameShapes || (this.frameShapes = { bottom: t11.polyhedron().add(), top: t11.polyhedron().add(), left: t11.polyhedron().add(), right: t11.polyhedron().add(), back: t11.polyhedron().add(), front: t11.polyhedron().add() }), this.frameShapes.bottom[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-bottom", zIndex: i3.bottom.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.bottom.color).brighten(0.1).get(), vertexes: [{ x: n3, y: c3, z: d3 }, { x: l3, y: c3, z: d3 }, { x: l3, y: c3, z: x2 }, { x: n3, y: c3, z: x2 }], enabled: i3.bottom.visible }, { fill: P(i3.bottom.color).brighten(0.1).get(), vertexes: [{ x: s3, y: r3, z: h3 }, { x: a3, y: r3, z: h3 }, { x: a3, y: r3, z: 0 }, { x: s3, y: r3, z: 0 }], enabled: i3.bottom.visible }, { fill: P(i3.bottom.color).brighten(-0.1).get(), vertexes: [{ x: n3, y: c3, z: d3 }, { x: n3, y: c3, z: x2 }, { x: s3, y: r3, z: h3 }, { x: s3, y: r3, z: 0 }], enabled: i3.bottom.visible && !i3.left.visible }, { fill: P(i3.bottom.color).brighten(-0.1).get(), vertexes: [{ x: l3, y: c3, z: x2 }, { x: l3, y: c3, z: d3 }, { x: a3, y: r3, z: 0 }, { x: a3, y: r3, z: h3 }], enabled: i3.bottom.visible && !i3.right.visible }, { fill: P(i3.bottom.color).get(), vertexes: [{ x: l3, y: c3, z: d3 }, { x: n3, y: c3, z: d3 }, { x: s3, y: r3, z: 0 }, { x: a3, y: r3, z: 0 }], enabled: i3.bottom.visible && !i3.front.visible }, { fill: P(i3.bottom.color).get(), vertexes: [{ x: n3, y: c3, z: x2 }, { x: l3, y: c3, z: x2 }, { x: a3, y: r3, z: h3 }, { x: s3, y: r3, z: h3 }], enabled: i3.bottom.visible && !i3.back.visible }] }), this.frameShapes.top[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-top", zIndex: i3.top.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.top.color).brighten(0.1).get(), vertexes: [{ x: n3, y: p3, z: x2 }, { x: l3, y: p3, z: x2 }, { x: l3, y: p3, z: d3 }, { x: n3, y: p3, z: d3 }], enabled: i3.top.visible }, { fill: P(i3.top.color).brighten(0.1).get(), vertexes: [{ x: s3, y: o3, z: 0 }, { x: a3, y: o3, z: 0 }, { x: a3, y: o3, z: h3 }, { x: s3, y: o3, z: h3 }], enabled: i3.top.visible }, { fill: P(i3.top.color).brighten(-0.1).get(), vertexes: [{ x: n3, y: p3, z: x2 }, { x: n3, y: p3, z: d3 }, { x: s3, y: o3, z: 0 }, { x: s3, y: o3, z: h3 }], enabled: i3.top.visible && !i3.left.visible }, { fill: P(i3.top.color).brighten(-0.1).get(), vertexes: [{ x: l3, y: p3, z: d3 }, { x: l3, y: p3, z: x2 }, { x: a3, y: o3, z: h3 }, { x: a3, y: o3, z: 0 }], enabled: i3.top.visible && !i3.right.visible }, { fill: P(i3.top.color).get(), vertexes: [{ x: n3, y: p3, z: d3 }, { x: l3, y: p3, z: d3 }, { x: a3, y: o3, z: 0 }, { x: s3, y: o3, z: 0 }], enabled: i3.top.visible && !i3.front.visible }, { fill: P(i3.top.color).get(), vertexes: [{ x: l3, y: p3, z: x2 }, { x: n3, y: p3, z: x2 }, { x: s3, y: o3, z: h3 }, { x: a3, y: o3, z: h3 }], enabled: i3.top.visible && !i3.back.visible }] }), this.frameShapes.left[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-left", zIndex: i3.left.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.left.color).brighten(0.1).get(), vertexes: [{ x: n3, y: c3, z: d3 }, { x: s3, y: r3, z: 0 }, { x: s3, y: r3, z: h3 }, { x: n3, y: c3, z: x2 }], enabled: i3.left.visible && !i3.bottom.visible }, { fill: P(i3.left.color).brighten(0.1).get(), vertexes: [{ x: n3, y: p3, z: x2 }, { x: s3, y: o3, z: h3 }, { x: s3, y: o3, z: 0 }, { x: n3, y: p3, z: d3 }], enabled: i3.left.visible && !i3.top.visible }, { fill: P(i3.left.color).brighten(-0.1).get(), vertexes: [{ x: n3, y: c3, z: x2 }, { x: n3, y: p3, z: x2 }, { x: n3, y: p3, z: d3 }, { x: n3, y: c3, z: d3 }], enabled: i3.left.visible }, { fill: P(i3.left.color).brighten(-0.1).get(), vertexes: [{ x: s3, y: o3, z: h3 }, { x: s3, y: r3, z: h3 }, { x: s3, y: r3, z: 0 }, { x: s3, y: o3, z: 0 }], enabled: i3.left.visible }, { fill: P(i3.left.color).get(), vertexes: [{ x: n3, y: c3, z: d3 }, { x: n3, y: p3, z: d3 }, { x: s3, y: o3, z: 0 }, { x: s3, y: r3, z: 0 }], enabled: i3.left.visible && !i3.front.visible }, { fill: P(i3.left.color).get(), vertexes: [{ x: n3, y: p3, z: x2 }, { x: n3, y: c3, z: x2 }, { x: s3, y: r3, z: h3 }, { x: s3, y: o3, z: h3 }], enabled: i3.left.visible && !i3.back.visible }] }), this.frameShapes.right[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-right", zIndex: i3.right.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.right.color).brighten(0.1).get(), vertexes: [{ x: l3, y: c3, z: x2 }, { x: a3, y: r3, z: h3 }, { x: a3, y: r3, z: 0 }, { x: l3, y: c3, z: d3 }], enabled: i3.right.visible && !i3.bottom.visible }, { fill: P(i3.right.color).brighten(0.1).get(), vertexes: [{ x: l3, y: p3, z: d3 }, { x: a3, y: o3, z: 0 }, { x: a3, y: o3, z: h3 }, { x: l3, y: p3, z: x2 }], enabled: i3.right.visible && !i3.top.visible }, { fill: P(i3.right.color).brighten(-0.1).get(), vertexes: [{ x: a3, y: o3, z: 0 }, { x: a3, y: r3, z: 0 }, { x: a3, y: r3, z: h3 }, { x: a3, y: o3, z: h3 }], enabled: i3.right.visible }, { fill: P(i3.right.color).brighten(-0.1).get(), vertexes: [{ x: l3, y: c3, z: d3 }, { x: l3, y: p3, z: d3 }, { x: l3, y: p3, z: x2 }, { x: l3, y: c3, z: x2 }], enabled: i3.right.visible }, { fill: P(i3.right.color).get(), vertexes: [{ x: l3, y: p3, z: d3 }, { x: l3, y: c3, z: d3 }, { x: a3, y: r3, z: 0 }, { x: a3, y: o3, z: 0 }], enabled: i3.right.visible && !i3.front.visible }, { fill: P(i3.right.color).get(), vertexes: [{ x: l3, y: c3, z: x2 }, { x: l3, y: p3, z: x2 }, { x: a3, y: o3, z: h3 }, { x: a3, y: r3, z: h3 }], enabled: i3.right.visible && !i3.back.visible }] }), this.frameShapes.back[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-back", zIndex: i3.back.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.back.color).brighten(0.1).get(), vertexes: [{ x: l3, y: c3, z: x2 }, { x: n3, y: c3, z: x2 }, { x: s3, y: r3, z: h3 }, { x: a3, y: r3, z: h3 }], enabled: i3.back.visible && !i3.bottom.visible }, { fill: P(i3.back.color).brighten(0.1).get(), vertexes: [{ x: n3, y: p3, z: x2 }, { x: l3, y: p3, z: x2 }, { x: a3, y: o3, z: h3 }, { x: s3, y: o3, z: h3 }], enabled: i3.back.visible && !i3.top.visible }, { fill: P(i3.back.color).brighten(-0.1).get(), vertexes: [{ x: n3, y: c3, z: x2 }, { x: n3, y: p3, z: x2 }, { x: s3, y: o3, z: h3 }, { x: s3, y: r3, z: h3 }], enabled: i3.back.visible && !i3.left.visible }, { fill: P(i3.back.color).brighten(-0.1).get(), vertexes: [{ x: l3, y: p3, z: x2 }, { x: l3, y: c3, z: x2 }, { x: a3, y: r3, z: h3 }, { x: a3, y: o3, z: h3 }], enabled: i3.back.visible && !i3.right.visible }, { fill: P(i3.back.color).get(), vertexes: [{ x: s3, y: o3, z: h3 }, { x: a3, y: o3, z: h3 }, { x: a3, y: r3, z: h3 }, { x: s3, y: r3, z: h3 }], enabled: i3.back.visible }, { fill: P(i3.back.color).get(), vertexes: [{ x: n3, y: c3, z: x2 }, { x: l3, y: c3, z: x2 }, { x: l3, y: p3, z: x2 }, { x: n3, y: p3, z: x2 }], enabled: i3.back.visible }] }), this.frameShapes.front[y2]({ class: "highcharts-3d-frame highcharts-3d-frame-front", zIndex: i3.front.frontFacing ? -1e3 : 1e3, faces: [{ fill: P(i3.front.color).brighten(0.1).get(), vertexes: [{ x: n3, y: c3, z: d3 }, { x: l3, y: c3, z: d3 }, { x: a3, y: r3, z: 0 }, { x: s3, y: r3, z: 0 }], enabled: i3.front.visible && !i3.bottom.visible }, { fill: P(i3.front.color).brighten(0.1).get(), vertexes: [{ x: l3, y: p3, z: d3 }, { x: n3, y: p3, z: d3 }, { x: s3, y: o3, z: 0 }, { x: a3, y: o3, z: 0 }], enabled: i3.front.visible && !i3.top.visible }, { fill: P(i3.front.color).brighten(-0.1).get(), vertexes: [{ x: n3, y: p3, z: d3 }, { x: n3, y: c3, z: d3 }, { x: s3, y: r3, z: 0 }, { x: s3, y: o3, z: 0 }], enabled: i3.front.visible && !i3.left.visible }, { fill: P(i3.front.color).brighten(-0.1).get(), vertexes: [{ x: l3, y: c3, z: d3 }, { x: l3, y: p3, z: d3 }, { x: a3, y: o3, z: 0 }, { x: a3, y: r3, z: 0 }], enabled: i3.front.visible && !i3.right.visible }, { fill: P(i3.front.color).get(), vertexes: [{ x: a3, y: o3, z: 0 }, { x: s3, y: o3, z: 0 }, { x: s3, y: r3, z: 0 }, { x: a3, y: r3, z: 0 }], enabled: i3.front.visible }, { fill: P(i3.front.color).get(), vertexes: [{ x: l3, y: c3, z: d3 }, { x: n3, y: c3, z: d3 }, { x: n3, y: p3, z: d3 }, { x: l3, y: p3, z: d3 }], enabled: i3.front.visible }] });
          }
        }
        function s2() {
          this.styledMode && [{ name: "darker", slope: 0.6 }, { name: "brighter", slope: 1.4 }].forEach(function(t11) {
            this.renderer.definition({ tagName: "filter", attributes: { id: "highcharts-" + t11.name }, children: [{ tagName: "feComponentTransfer", children: [{ tagName: "feFuncR", attributes: { type: "linear", slope: t11.slope } }, { tagName: "feFuncG", attributes: { type: "linear", slope: t11.slope } }, { tagName: "feFuncB", attributes: { type: "linear", slope: t11.slope } }] }] });
          }, this);
        }
        function a2() {
          let t11 = this.options;
          this.is3d() && (t11.series || []).forEach(function(e3) {
            "scatter" === (e3.type || t11.chart.type || t11.chart.defaultSeriesType) && (e3.type = "scatter3d");
          });
        }
        function o2() {
          let t11 = this.options.chart.options3d;
          if (this.chart3d && this.is3d()) {
            t11 && (t11.alpha = t11.alpha % 360 + (t11.alpha >= 0 ? 0 : 360), t11.beta = t11.beta % 360 + (t11.beta >= 0 ? 0 : 360));
            let e3 = this.inverted, i3 = this.clipBox, s3 = this.margin;
            i3[e3 ? "y" : "x"] = -(s3[3] || 0), i3[e3 ? "x" : "y"] = -(s3[0] || 0), i3[e3 ? "height" : "width"] = this.chartWidth + (s3[3] || 0) + (s3[1] || 0), i3[e3 ? "width" : "height"] = this.chartHeight + (s3[0] || 0) + (s3[2] || 0), this.scale3d = 1, true === t11.fitToPlot && (this.scale3d = this.chart3d.getScale(t11.depth)), this.chart3d.frame3d = this.chart3d.get3dFrame();
          }
        }
        function r2() {
          this.is3d() && (this.isDirtyBox = true);
        }
        function h2() {
          this.chart3d && this.is3d() && (this.chart3d.frame3d = this.chart3d.get3dFrame());
        }
        function n2() {
          this.chart3d || (this.chart3d = new d2(this));
        }
        function l2(t11) {
          return this.is3d() || t11.apply(this, [].slice.call(arguments, 1));
        }
        function p2(t11) {
          let e3, i3 = this.series.length;
          if (this.is3d()) for (; i3--; ) (e3 = this.series[i3]).translate(), e3.render();
          else t11.call(this);
        }
        function c2(t11) {
          t11.apply(this, [].slice.call(arguments, 1)), this.is3d() && (this.container.className += " highcharts-3d-chart");
        }
        t10.defaultOptions = { chart: { options3d: { enabled: false, alpha: 0, beta: 0, depth: 100, fitToPlot: true, viewDistance: 25, axisLabelPosition: null, frame: { visible: "default", size: 1, bottom: {}, top: {}, left: {}, right: {}, back: {}, front: {} } } } }, t10.compose = function(d3, x2) {
          let y2 = d3.prototype, f2 = x2.prototype;
          y2.is3d = function() {
            var _a;
            return !!((_a = this.options.chart.options3d) == null ? void 0 : _a.enabled);
          }, y2.propsRequireDirtyBox.push("chart.options3d"), y2.propsRequireUpdateSeries.push("chart.options3d"), f2.matrixSetter = function() {
            let t11;
            if (this.pos < 1 && (L(this.start) || L(this.end))) {
              let e3 = this.start || [1, 0, 0, 1, 0, 0], i3 = this.end || [1, 0, 0, 1, 0, 0];
              t11 = [];
              for (let s3 = 0; s3 < 6; s3++) t11.push(this.pos * i3[s3] + (1 - this.pos) * e3[s3]);
            } else t11 = this.end;
            this.elem.attr(this.prop, t11, null, true);
          }, I(true, k, t10.defaultOptions), D(d3, "init", n2), D(d3, "addSeries", e2), D(d3, "afterDrawChartBox", i2), D(d3, "afterGetContainer", s2), D(d3, "afterInit", a2), D(d3, "afterSetChartSize", o2), D(d3, "beforeRedraw", r2), D(d3, "beforeRender", h2), X(y2, "isInsidePlot", l2), X(y2, "renderSeries", p2), X(y2, "setClassName", c2);
        };
        class d2 {
          constructor(t11) {
            this.chart = t11;
          }
          get3dFrame() {
            let t11 = this.chart, e3 = t11.options.chart.options3d, i3 = e3.frame, s3 = t11.plotLeft, a3 = t11.plotLeft + t11.plotWidth, o3 = t11.plotTop, r3 = t11.plotTop + t11.plotHeight, h3 = e3.depth, n3 = function(e4) {
              let i4 = w(e4, t11);
              return i4 > 0.5 ? 1 : i4 < -0.5 ? -1 : 0;
            }, l3 = n3([{ x: s3, y: r3, z: h3 }, { x: a3, y: r3, z: h3 }, { x: a3, y: r3, z: 0 }, { x: s3, y: r3, z: 0 }]), p3 = n3([{ x: s3, y: o3, z: 0 }, { x: a3, y: o3, z: 0 }, { x: a3, y: o3, z: h3 }, { x: s3, y: o3, z: h3 }]), c3 = n3([{ x: s3, y: o3, z: 0 }, { x: s3, y: o3, z: h3 }, { x: s3, y: r3, z: h3 }, { x: s3, y: r3, z: 0 }]), d3 = n3([{ x: a3, y: o3, z: h3 }, { x: a3, y: o3, z: 0 }, { x: a3, y: r3, z: 0 }, { x: a3, y: r3, z: h3 }]), x2 = n3([{ x: s3, y: r3, z: 0 }, { x: a3, y: r3, z: 0 }, { x: a3, y: o3, z: 0 }, { x: s3, y: o3, z: 0 }]), y2 = n3([{ x: s3, y: o3, z: h3 }, { x: a3, y: o3, z: h3 }, { x: a3, y: r3, z: h3 }, { x: s3, y: r3, z: h3 }]), f2 = false, u2 = false, z2 = false, g2 = false;
            [].concat(t11.xAxis, t11.yAxis, t11.zAxis).forEach(function(t12) {
              t12 && (t12.horiz ? t12.opposite ? u2 = true : f2 = true : t12.opposite ? g2 = true : z2 = true);
            });
            let b2 = function(t12, e4, i4) {
              let s4 = ["size", "color", "visible"], a4 = {};
              for (let e5 = 0; e5 < s4.length; e5++) {
                let i5 = s4[e5];
                for (let e6 = 0; e6 < t12.length; e6++) if ("object" == typeof t12[e6]) {
                  let s5 = t12[e6][i5];
                  if (null != s5) {
                    a4[i5] = s5;
                    break;
                  }
                }
              }
              let o4 = i4;
              return true === a4.visible || false === a4.visible ? o4 = a4.visible : "auto" === a4.visible && (o4 = e4 > 0), { size: T(a4.size, 1), color: T(a4.color, "none"), frontFacing: e4 > 0, visible: o4 };
            }, m2 = { axes: {}, bottom: b2([i3.bottom, i3.top, i3], l3, f2), top: b2([i3.top, i3.bottom, i3], p3, u2), left: b2([i3.left, i3.right, i3.side, i3], c3, z2), right: b2([i3.right, i3.left, i3.side, i3], d3, g2), back: b2([i3.back, i3.front, i3], y2, true), front: b2([i3.front, i3.back, i3], x2, false) };
            if ("auto" === e3.axisLabelPosition) {
              let e4 = function(t12, e5) {
                return t12.visible !== e5.visible || t12.visible && e5.visible && t12.frontFacing !== e5.frontFacing;
              }, i4 = [];
              e4(m2.left, m2.front) && i4.push({ y: (o3 + r3) / 2, x: s3, z: 0, xDir: { x: 1, y: 0, z: 0 } }), e4(m2.left, m2.back) && i4.push({ y: (o3 + r3) / 2, x: s3, z: h3, xDir: { x: 0, y: 0, z: -1 } }), e4(m2.right, m2.front) && i4.push({ y: (o3 + r3) / 2, x: a3, z: 0, xDir: { x: 0, y: 0, z: 1 } }), e4(m2.right, m2.back) && i4.push({ y: (o3 + r3) / 2, x: a3, z: h3, xDir: { x: -1, y: 0, z: 0 } });
              let n4 = [];
              e4(m2.bottom, m2.front) && n4.push({ x: (s3 + a3) / 2, y: r3, z: 0, xDir: { x: 1, y: 0, z: 0 } }), e4(m2.bottom, m2.back) && n4.push({ x: (s3 + a3) / 2, y: r3, z: h3, xDir: { x: -1, y: 0, z: 0 } });
              let l4 = [];
              e4(m2.top, m2.front) && l4.push({ x: (s3 + a3) / 2, y: o3, z: 0, xDir: { x: 1, y: 0, z: 0 } }), e4(m2.top, m2.back) && l4.push({ x: (s3 + a3) / 2, y: o3, z: h3, xDir: { x: -1, y: 0, z: 0 } });
              let p4 = [];
              e4(m2.bottom, m2.left) && p4.push({ z: (0 + h3) / 2, y: r3, x: s3, xDir: { x: 0, y: 0, z: -1 } }), e4(m2.bottom, m2.right) && p4.push({ z: (0 + h3) / 2, y: r3, x: a3, xDir: { x: 0, y: 0, z: 1 } });
              let c4 = [];
              e4(m2.top, m2.left) && c4.push({ z: (0 + h3) / 2, y: o3, x: s3, xDir: { x: 0, y: 0, z: -1 } }), e4(m2.top, m2.right) && c4.push({ z: (0 + h3) / 2, y: o3, x: a3, xDir: { x: 0, y: 0, z: 1 } });
              let d4 = function(e5, i5, s4) {
                if (0 === e5.length) return null;
                if (1 === e5.length) return e5[0];
                let a4 = S(e5, t11, false), o4 = 0;
                for (let t12 = 1; t12 < a4.length; t12++) s4 * a4[t12][i5] > s4 * a4[o4][i5] ? o4 = t12 : s4 * a4[t12][i5] == s4 * a4[o4][i5] && a4[t12].z < a4[o4].z && (o4 = t12);
                return e5[o4];
              };
              m2.axes = { y: { left: d4(i4, "x", -1), right: d4(i4, "x", 1) }, x: { top: d4(l4, "y", -1), bottom: d4(n4, "y", 1) }, z: { top: d4(c4, "y", -1), bottom: d4(p4, "y", 1) } };
            } else m2.axes = { y: { left: { x: s3, z: 0, xDir: { x: 1, y: 0, z: 0 } }, right: { x: a3, z: 0, xDir: { x: 0, y: 0, z: 1 } } }, x: { top: { y: o3, z: 0, xDir: { x: 1, y: 0, z: 0 } }, bottom: { y: r3, z: 0, xDir: { x: 1, y: 0, z: 0 } } }, z: { top: { x: z2 ? a3 : s3, y: o3, xDir: z2 ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 } }, bottom: { x: z2 ? a3 : s3, y: r3, xDir: z2 ? { x: 0, y: 0, z: 1 } : { x: 0, y: 0, z: -1 } } } };
            return m2;
          }
          getScale(t11) {
            let e3 = this.chart, i3 = e3.plotLeft, s3 = e3.plotWidth + i3, a3 = e3.plotTop, o3 = e3.plotHeight + a3, r3 = i3 + e3.plotWidth / 2, h3 = a3 + e3.plotHeight / 2, n3 = { minX: Number.MAX_VALUE, maxX: -Number.MAX_VALUE, minY: Number.MAX_VALUE, maxY: -Number.MAX_VALUE }, l3, p3 = 1;
            return l3 = [{ x: i3, y: a3, z: 0 }, { x: i3, y: a3, z: t11 }], [0, 1].forEach(function(t12) {
              l3.push({ x: s3, y: l3[t12].y, z: l3[t12].z });
            }), [0, 1, 2, 3].forEach(function(t12) {
              l3.push({ x: l3[t12].x, y: o3, z: l3[t12].z });
            }), (l3 = S(l3, e3, false)).forEach(function(t12) {
              n3.minX = Math.min(n3.minX, t12.x), n3.maxX = Math.max(n3.maxX, t12.x), n3.minY = Math.min(n3.minY, t12.y), n3.maxY = Math.max(n3.maxY, t12.y);
            }), i3 > n3.minX && (p3 = Math.min(p3, 1 - Math.abs((i3 + r3) / (n3.minX + r3)) % 1)), s3 < n3.maxX && (p3 = Math.min(p3, (s3 - r3) / (n3.maxX - r3))), a3 > n3.minY && (p3 = n3.minY < 0 ? Math.min(p3, (a3 + h3) / (-n3.minY + a3 + h3)) : Math.min(p3, 1 - (a3 + h3) / (n3.minY + h3) % 1)), o3 < n3.maxY && (p3 = Math.min(p3, Math.abs((o3 - h3) / (n3.maxY - h3)))), p3;
          }
        }
        t10.Additions = d2;
      }(n || (n = {}));
      let H = n;
      var Y = d(512), Z = d.n(Y);
      let { composed: C } = f(), { perspective: O } = A, { line: { prototype: R } } = Z().seriesTypes, { pushUnique: E, wrap: F } = f();
      function W(t10) {
        let e2 = t10.apply(this, [].slice.call(arguments, 1));
        if (!this.chart.is3d()) return e2;
        let i2 = R.getGraphPath, s2 = this.options, a2 = Math.round(this.yAxis.getThreshold(s2.threshold)), o2 = [];
        if (this.rawPointsX) for (let t11 = 0; t11 < this.points.length; t11++) o2.push({ x: this.rawPointsX[t11], y: s2.stacking ? this.points[t11].yBottom : a2, z: this.zPadding });
        let r2 = this.chart.options.chart.options3d;
        o2 = O(o2, this.chart, true).map((t11) => ({ plotX: t11.x, plotY: t11.y, plotZ: t11.z })), this.group && r2 && r2.depth && r2.beta && (this.markerGroup && (this.markerGroup.add(this.group), this.markerGroup.attr({ translateX: 0, translateY: 0 })), this.group.attr({ zIndex: Math.max(1, r2.beta > 270 || r2.beta < 90 ? r2.depth - Math.round(this.zPadding || 0) : Math.round(this.zPadding || 0)) })), o2.reversed = true;
        let h2 = i2.call(this, o2, true, true);
        if (h2[0] && "M" === h2[0][0] && (h2[0] = ["L", h2[0][1], h2[0][2]]), this.areaPath) {
          let t11 = this.areaPath.splice(0, this.areaPath.length / 2).concat(h2);
          t11.xMap = this.areaPath.xMap, this.areaPath = t11;
        }
        return this.graphPath = e2, e2;
      }
      let _ = { labels: { position3d: "offset", skew3d: false }, title: { position3d: null, skew3d: null } }, { composed: B } = f(), { addEvent: G, extend: j, pushUnique: N, wrap: U } = f();
      function q(t10) {
        let e2 = this.axis.axis3D;
        e2 && j(t10.pos, e2.fix3dPosition(t10.pos));
      }
      function V(t10) {
        let e2 = this.axis.axis3D, i2 = t10.apply(this, [].slice.call(arguments, 1));
        if (e2) {
          let t11 = i2[0], s2 = i2[1];
          if ("M" === t11[0] && "L" === s2[0]) {
            let i3 = [e2.fix3dPosition({ x: t11[1], y: t11[2], z: 0 }), e2.fix3dPosition({ x: s2[1], y: s2[2], z: 0 })];
            return this.axis.chart.renderer.toLineSegments(i3);
          }
        }
        return i2;
      }
      let J = function(t10) {
        N(B, "Axis.Tick3D") && (G(t10, "afterGetLabelPosition", q), U(t10.prototype, "getMarkPath", V));
      }, { defaultOptions: K } = f(), { deg2rad: Q } = f(), { perspective: $, perspective3D: tt, shapeArea: te } = A, { addEvent: ti, merge: ts, pick: ta, wrap: to } = f();
      function tr() {
        var _a;
        let t10 = this.chart, e2 = this.options;
        ((_a = t10.is3d) == null ? void 0 : _a.call(t10)) && "colorAxis" !== this.coll && (e2.tickWidth = ta(e2.tickWidth, 0), e2.gridLineWidth = ta(e2.gridLineWidth, 1));
      }
      function th(t10) {
        this.chart.is3d() && "colorAxis" !== this.coll && t10.point && (t10.point.crosshairPos = this.isXAxis ? t10.point.axisXpos : this.len - t10.point.axisYpos);
      }
      function tn() {
        this.axis3D || (this.axis3D = new ty(this));
      }
      function tl(t10) {
        return this.chart.is3d() && "colorAxis" !== this.coll ? [] : t10.apply(this, [].slice.call(arguments, 1));
      }
      function tp(t10) {
        if (!this.chart.is3d() || "colorAxis" === this.coll) return t10.apply(this, [].slice.call(arguments, 1));
        let e2 = arguments, i2 = e2[1], s2 = e2[2], a2 = [], o2 = this.getPlotLinePath({ value: i2 }), r2 = this.getPlotLinePath({ value: s2 });
        if (o2 && r2) for (let t11 = 0; t11 < o2.length; t11 += 2) {
          let e3 = o2[t11], i3 = o2[t11 + 1], s3 = r2[t11], h2 = r2[t11 + 1];
          "M" === e3[0] && "L" === i3[0] && "M" === s3[0] && "L" === h2[0] && a2.push(e3, i3, h2, ["L", s3[1], s3[2]], ["Z"]);
        }
        return a2;
      }
      function tc(t10) {
        let e2 = this.axis3D, i2 = this.chart, s2 = t10.apply(this, [].slice.call(arguments, 1));
        if ("colorAxis" === this.coll || !i2.chart3d || !i2.is3d() || null === s2) return s2;
        let a2 = i2.options.chart.options3d, o2 = this.isZAxis ? i2.plotWidth : a2.depth, r2 = i2.chart3d.frame3d, h2 = s2[0], n2 = s2[1], l2, p2 = [];
        return "M" === h2[0] && "L" === n2[0] && (l2 = [e2.swapZ({ x: h2[1], y: h2[2], z: 0 }), e2.swapZ({ x: h2[1], y: h2[2], z: o2 }), e2.swapZ({ x: n2[1], y: n2[2], z: 0 }), e2.swapZ({ x: n2[1], y: n2[2], z: o2 })], this.horiz ? (this.isZAxis ? (r2.left.visible && p2.push(l2[0], l2[2]), r2.right.visible && p2.push(l2[1], l2[3])) : (r2.front.visible && p2.push(l2[0], l2[2]), r2.back.visible && p2.push(l2[1], l2[3])), r2.top.visible && p2.push(l2[0], l2[1]), r2.bottom.visible && p2.push(l2[2], l2[3])) : (r2.front.visible && p2.push(l2[0], l2[2]), r2.back.visible && p2.push(l2[1], l2[3]), r2.left.visible && p2.push(l2[0], l2[1]), r2.right.visible && p2.push(l2[2], l2[3])), p2 = $(p2, this.chart, false)), i2.renderer.toLineSegments(p2);
      }
      function td(t10, e2) {
        var _a, _b;
        let { chart: i2, gridGroup: s2, tickPositions: a2, ticks: o2 } = this;
        if (this.categories && i2.frameShapes && i2.is3d() && s2 && e2 && e2.label) {
          let t11, r2, h2, n2 = s2.element.childNodes[0].getBBox(), l2 = i2.frameShapes.left.getBBox(), p2 = i2.options.chart.options3d, c2 = { x: i2.plotWidth / 2, y: i2.plotHeight / 2, z: p2.depth / 2, vd: ta(p2.depth, 1) * ta(p2.viewDistance, 0) }, d2 = a2.indexOf(e2.pos), x2 = o2[a2[d2 - 1]], y2 = o2[a2[d2 + 1]];
          return ((_a = x2 == null ? void 0 : x2.label) == null ? void 0 : _a.xy) && (r2 = tt({ x: x2.label.xy.x, y: x2.label.xy.y, z: null }, c2, c2.vd)), ((_b = y2 == null ? void 0 : y2.label) == null ? void 0 : _b.xy) && (h2 = tt({ x: y2.label.xy.x, y: y2.label.xy.y, z: null }, c2, c2.vd)), t11 = tt(t11 = { x: e2.label.xy.x, y: e2.label.xy.y, z: null }, c2, c2.vd), Math.abs(r2 ? t11.x - r2.x : h2 ? h2.x - t11.x : n2.x - l2.x);
        }
        return t10.apply(this, [].slice.call(arguments, 1));
      }
      function tx(t10) {
        let e2 = t10.apply(this, [].slice.call(arguments, 1));
        return this.axis3D ? this.axis3D.fix3dPosition(e2, true) : e2;
      }
      class ty {
        static compose(t10, e2) {
          if (J(e2), !t10.keepProps.includes("axis3D")) {
            ts(true, K.xAxis, _), t10.keepProps.push("axis3D"), ti(t10, "init", tn), ti(t10, "afterSetOptions", tr), ti(t10, "drawCrosshair", th);
            let e3 = t10.prototype;
            to(e3, "getLinePath", tl), to(e3, "getPlotBandPath", tp), to(e3, "getPlotLinePath", tc), to(e3, "getSlotWidth", td), to(e3, "getTitlePosition", tx);
          }
        }
        constructor(t10) {
          this.axis = t10;
        }
        fix3dPosition(t10, e2) {
          let i2 = this.axis, s2 = i2.chart;
          if ("colorAxis" === i2.coll || !s2.chart3d || !s2.is3d()) return t10;
          let a2 = Q * s2.options.chart.options3d.alpha, o2 = Q * s2.options.chart.options3d.beta, r2 = ta(e2 && i2.options.title.position3d, i2.options.labels.position3d), h2 = ta(e2 && i2.options.title.skew3d, i2.options.labels.skew3d), n2 = s2.chart3d.frame3d, l2 = s2.plotLeft, p2 = s2.plotWidth + l2, c2 = s2.plotTop, d2 = s2.plotHeight + c2, x2 = 0, y2 = 0, f2, u2 = { x: 0, y: 1, z: 0 }, z2 = false;
          if (t10 = i2.axis3D.swapZ({ x: t10.x, y: t10.y, z: 0 }), i2.isZAxis) if (i2.opposite) {
            if (null === n2.axes.z.top) return {};
            y2 = t10.y - c2, t10.x = n2.axes.z.top.x, t10.y = n2.axes.z.top.y, f2 = n2.axes.z.top.xDir, z2 = !n2.top.frontFacing;
          } else {
            if (null === n2.axes.z.bottom) return {};
            y2 = t10.y - d2, t10.x = n2.axes.z.bottom.x, t10.y = n2.axes.z.bottom.y, f2 = n2.axes.z.bottom.xDir, z2 = !n2.bottom.frontFacing;
          }
          else if (i2.horiz) if (i2.opposite) {
            if (null === n2.axes.x.top) return {};
            y2 = t10.y - c2, t10.y = n2.axes.x.top.y, t10.z = n2.axes.x.top.z, f2 = n2.axes.x.top.xDir, z2 = !n2.top.frontFacing;
          } else {
            if (null === n2.axes.x.bottom) return {};
            y2 = t10.y - d2, t10.y = n2.axes.x.bottom.y, t10.z = n2.axes.x.bottom.z, f2 = n2.axes.x.bottom.xDir, z2 = !n2.bottom.frontFacing;
          }
          else if (i2.opposite) {
            if (null === n2.axes.y.right) return {};
            x2 = t10.x - p2, t10.x = n2.axes.y.right.x, t10.z = n2.axes.y.right.z, f2 = { x: (f2 = n2.axes.y.right.xDir).z, y: f2.y, z: -f2.x };
          } else {
            if (null === n2.axes.y.left) return {};
            x2 = t10.x - l2, t10.x = n2.axes.y.left.x, t10.z = n2.axes.y.left.z, f2 = n2.axes.y.left.xDir;
          }
          if ("chart" === r2) ;
          else if ("flap" === r2) if (i2.horiz) {
            let t11 = Math.sin(a2), e3 = Math.cos(a2);
            z2 && (t11 = -t11), u2 = { x: f2.z * t11, y: e3, z: -f2.x * t11 };
          } else f2 = { x: Math.cos(o2), y: 0, z: Math.sin(o2) };
          else if ("ortho" === r2) if (i2.horiz) {
            let t11 = Math.sin(a2), e3 = Math.cos(a2), i3 = { x: Math.sin(o2) * e3, y: -t11, z: -e3 * Math.cos(o2) }, s3 = 1 / Math.sqrt((u2 = { x: f2.y * i3.z - f2.z * i3.y, y: f2.z * i3.x - f2.x * i3.z, z: f2.x * i3.y - f2.y * i3.x }).x * u2.x + u2.y * u2.y + u2.z * u2.z);
            z2 && (s3 = -s3), u2 = { x: s3 * u2.x, y: s3 * u2.y, z: s3 * u2.z };
          } else f2 = { x: Math.cos(o2), y: 0, z: Math.sin(o2) };
          else i2.horiz ? u2 = { x: Math.sin(o2) * Math.sin(a2), y: Math.cos(a2), z: -Math.cos(o2) * Math.sin(a2) } : f2 = { x: Math.cos(o2), y: 0, z: Math.sin(o2) };
          t10.x += x2 * f2.x + y2 * u2.x, t10.y += x2 * f2.y + y2 * u2.y, t10.z += x2 * f2.z + y2 * u2.z;
          let g2 = $([t10], i2.chart)[0];
          if (h2) {
            0 > te($([t10, { x: t10.x + f2.x, y: t10.y + f2.y, z: t10.z + f2.z }, { x: t10.x + u2.x, y: t10.y + u2.y, z: t10.z + u2.z }], i2.chart)) && (f2 = { x: -f2.x, y: -f2.y, z: -f2.z });
            let e3 = $([{ x: t10.x, y: t10.y, z: t10.z }, { x: t10.x + f2.x, y: t10.y + f2.y, z: t10.z + f2.z }, { x: t10.x + u2.x, y: t10.y + u2.y, z: t10.z + u2.z }], i2.chart);
            g2.matrix = [e3[1].x - e3[0].x, e3[1].y - e3[0].y, e3[2].x - e3[0].x, e3[2].y - e3[0].y, g2.x, g2.y], g2.matrix[4] -= g2.x * g2.matrix[0] + g2.y * g2.matrix[2], g2.matrix[5] -= g2.x * g2.matrix[1] + g2.y * g2.matrix[3];
          }
          return g2;
        }
        swapZ(t10, e2) {
          let i2 = this.axis;
          if (i2.isZAxis) {
            let s2 = e2 ? 0 : i2.chart.plotLeft;
            return { x: s2 + t10.z, y: t10.y, z: t10.x - s2 };
          }
          return t10;
        }
      }
      var tf = d(608), tu = d.n(tf), tz = d(820), tg = d.n(tz);
      let { composed: tb } = f(), { perspective: tm } = A, { addEvent: tv, extend: tM, isNumber: tA, merge: tP, pick: tk, pushUnique: tS } = f();
      class tw extends tg() {
        static compose(t10) {
          tS(tb, "Core.Series3D") && (tv(t10, "afterTranslate", function() {
            this.chart.is3d() && this.translate3dPoints();
          }), tM(t10.prototype, { translate3dPoints: tw.prototype.translate3dPoints }));
        }
        translate3dPoints() {
          let t10, e2, i2 = this, s2 = i2.options, a2 = i2.chart, o2 = tk(i2.zAxis, a2.options.zAxis[0]), r2 = [], h2 = [], n2 = s2.stacking ? tA(s2.stack) ? s2.stack : 0 : i2.index || 0;
          i2.zPadding = n2 * (s2.depth || 0 + (s2.groupZPadding || 1)), i2.data.forEach((t11) => {
            (o2 == null ? void 0 : o2.translate) ? (e2 = o2.logarithmic && o2.val2lin ? o2.val2lin(t11.z) : t11.z, t11.plotZ = o2.translate(e2), t11.isInside = !!t11.isInside && e2 >= o2.min && e2 <= o2.max) : t11.plotZ = i2.zPadding, t11.axisXpos = t11.plotX, t11.axisYpos = t11.plotY, t11.axisZpos = t11.plotZ, r2.push({ x: t11.plotX, y: t11.plotY, z: t11.plotZ }), h2.push(t11.plotX || 0);
          }), i2.rawPointsX = h2;
          let l2 = tm(r2, a2, true);
          i2.data.forEach((e3, i3) => {
            e3.plotX = (t10 = l2[i3]).x, e3.plotY = t10.y, e3.plotZ = t10.z;
          });
        }
      }
      tw.defaultOptions = tP(tg().defaultOptions);
      var tD = d(184), tL = d.n(tD);
      let { parse: tI } = z(), { Element: tT } = tu().getRendererType().prototype, { defined: tX, pick: tH } = f();
      class tY extends tT {
        constructor() {
          super(...arguments), this.parts = ["front", "top", "side"], this.pathType = "cuboid";
        }
        initArgs(t10) {
          let e2 = this.renderer, i2 = e2[this.pathType + "Path"](t10), s2 = i2.zIndexes;
          for (let t11 of this.parts) {
            let a2 = { class: "highcharts-3d-" + t11, zIndex: s2[t11] || 0 };
            e2.styledMode && ("top" === t11 ? a2.filter = "url(#highcharts-brighter)" : "side" === t11 && (a2.filter = "url(#highcharts-darker)")), this[t11] = e2.path(i2[t11]).attr(a2).add(this);
          }
          this.attr({ "stroke-linejoin": "round", zIndex: s2.group }), this.forcedSides = i2.forcedSides;
        }
        singleSetterForParts(t10, e2, i2, s2, a2, o2) {
          let r2 = {}, h2 = [null, null, s2 || "attr", a2, o2], n2 = i2 == null ? void 0 : i2.zIndexes;
          if (i2) {
            for (let e3 of ((n2 == null ? void 0 : n2.group) && this.attr({ zIndex: n2.group }), Object.keys(i2))) r2[e3] = {}, r2[e3][t10] = i2[e3], n2 && (r2[e3].zIndex = i2.zIndexes[e3] || 0);
            h2[1] = r2;
          } else r2[t10] = e2, h2[0] = r2;
          return this.processParts.apply(this, h2);
        }
        processParts(t10, e2, i2, s2, a2) {
          for (let o2 of this.parts) e2 && (t10 = tH(e2[o2], false)), false !== t10 && this[o2][i2](t10, s2, a2);
          return this;
        }
        destroy() {
          return this.processParts(null, null, "destroy"), super.destroy();
        }
        attr(t10, e2, i2, s2) {
          if ("string" == typeof t10 && void 0 !== e2) {
            let i3 = t10;
            (t10 = {})[i3] = e2;
          }
          return t10.shapeArgs || tX(t10.x) ? this.singleSetterForParts("d", null, this.renderer[this.pathType + "Path"](t10.shapeArgs || t10)) : super.attr(t10, void 0, i2, s2);
        }
        animate(t10, e2, i2) {
          if (tX(t10.x) && tX(t10.y)) {
            let s2 = this.renderer[this.pathType + "Path"](t10), a2 = s2.forcedSides;
            this.singleSetterForParts("d", null, s2, "animate", e2, i2), this.attr({ zIndex: s2.zIndexes.group }), a2 !== this.forcedSides && (this.forcedSides = a2, this.renderer.styledMode || this.fillSetter(this.fill));
          } else super.animate(t10, e2, i2);
          return this;
        }
        fillSetter(t10) {
          return this.forcedSides = this.forcedSides || [], this.singleSetterForParts("fill", null, { front: t10, top: tI(t10).brighten(this.forcedSides.indexOf("top") >= 0 ? 0 : 0.1).get(), side: tI(t10).brighten(this.forcedSides.indexOf("side") >= 0 ? 0 : -0.1).get() }), this.color = this.fill = t10, this;
        }
      }
      tY.types = { base: tY, cuboid: tY };
      let { animObject: tZ } = f(), { parse: tC } = z(), { charts: tO, deg2rad: tR } = f(), { perspective: tE, shapeArea: tF } = A, { defined: tW, extend: t_, merge: tB, pick: tG } = f(), tj = Math.cos, tN = Math.sin, tU = Math.PI, tq = 4 * (Math.sqrt(2) - 1) / 3 / (tU / 2);
      function tV(t10, e2, i2, s2, a2, o2, r2, h2) {
        let n2 = o2 - a2, l2 = [];
        return o2 > a2 && o2 - a2 > Math.PI / 2 + 1e-4 ? l2 = (l2 = l2.concat(tV(t10, e2, i2, s2, a2, a2 + Math.PI / 2, r2, h2))).concat(tV(t10, e2, i2, s2, a2 + Math.PI / 2, o2, r2, h2)) : o2 < a2 && a2 - o2 > Math.PI / 2 + 1e-4 ? l2 = (l2 = l2.concat(tV(t10, e2, i2, s2, a2, a2 - Math.PI / 2, r2, h2))).concat(tV(t10, e2, i2, s2, a2 - Math.PI / 2, o2, r2, h2)) : [["C", t10 + i2 * Math.cos(a2) - i2 * tq * n2 * Math.sin(a2) + r2, e2 + s2 * Math.sin(a2) + s2 * tq * n2 * Math.cos(a2) + h2, t10 + i2 * Math.cos(o2) + i2 * tq * n2 * Math.sin(o2) + r2, e2 + s2 * Math.sin(o2) - s2 * tq * n2 * Math.cos(o2) + h2, t10 + i2 * Math.cos(o2) + r2, e2 + s2 * Math.sin(o2) + h2]];
      }
      !function(t10) {
        function e2(t11, e3) {
          let i3 = [];
          for (let e4 of t11) i3.push(["L", e4.x, e4.y]);
          return t11.length && (i3[0][0] = "M", e3 && i3.push(["Z"])), i3;
        }
        function i2(t11) {
          let e3 = [], i3 = true;
          for (let s3 of t11) e3.push(i3 ? ["M", s3.x, s3.y] : ["L", s3.x, s3.y]), i3 = !i3;
          return e3;
        }
        function s2(t11) {
          let e3 = this, i3 = e3.Element.prototype, s3 = e3.createElement("path");
          return s3.vertexes = [], s3.insidePlotArea = false, s3.enabled = true, s3.attr = function(t12) {
            if ("object" == typeof t12 && (tW(t12.enabled) || tW(t12.vertexes) || tW(t12.insidePlotArea))) {
              this.enabled = tG(t12.enabled, this.enabled), this.vertexes = tG(t12.vertexes, this.vertexes), this.insidePlotArea = tG(t12.insidePlotArea, this.insidePlotArea), delete t12.enabled, delete t12.vertexes, delete t12.insidePlotArea;
              let i4 = tO[e3.chartIndex], s4 = tE(this.vertexes, i4, this.insidePlotArea), a3 = e3.toLinePath(s4, true), o3 = tF(s4);
              t12.d = a3, t12.visibility = this.enabled && o3 > 0 ? "inherit" : "hidden";
            }
            return i3.attr.apply(this, arguments);
          }, s3.animate = function(t12) {
            if ("object" == typeof t12 && (tW(t12.enabled) || tW(t12.vertexes) || tW(t12.insidePlotArea))) {
              this.enabled = tG(t12.enabled, this.enabled), this.vertexes = tG(t12.vertexes, this.vertexes), this.insidePlotArea = tG(t12.insidePlotArea, this.insidePlotArea), delete t12.enabled, delete t12.vertexes, delete t12.insidePlotArea;
              let i4 = tO[e3.chartIndex], s4 = tE(this.vertexes, i4, this.insidePlotArea), a3 = e3.toLinePath(s4, true), o3 = tF(s4), r3 = this.enabled && o3 > 0 ? "visible" : "hidden";
              t12.d = a3, this.attr("visibility", r3);
            }
            return i3.animate.apply(this, arguments);
          }, s3.attr(t11);
        }
        function a2(t11) {
          let e3 = this, i3 = e3.Element.prototype, s3 = e3.g(), a3 = s3.destroy;
          return this.styledMode || s3.attr({ "stroke-linejoin": "round" }), s3.faces = [], s3.destroy = function() {
            for (let t12 = 0; t12 < s3.faces.length; t12++) s3.faces[t12].destroy();
            return a3.call(this);
          }, s3.attr = function(t12, a4, o3, r3) {
            if ("object" == typeof t12 && tW(t12.faces)) {
              for (; s3.faces.length > t12.faces.length; ) s3.faces.pop().destroy();
              for (; s3.faces.length < t12.faces.length; ) s3.faces.push(e3.face3d().add(s3));
              for (let i4 = 0; i4 < t12.faces.length; i4++) e3.styledMode && delete t12.faces[i4].fill, s3.faces[i4].attr(t12.faces[i4], null, o3, r3);
              delete t12.faces;
            }
            return i3.attr.apply(this, arguments);
          }, s3.animate = function(t12, a4, o3) {
            if (t12 == null ? void 0 : t12.faces) {
              for (; s3.faces.length > t12.faces.length; ) s3.faces.pop().destroy();
              for (; s3.faces.length < t12.faces.length; ) s3.faces.push(e3.face3d().add(s3));
              for (let e4 = 0; e4 < t12.faces.length; e4++) s3.faces[e4].animate(t12.faces[e4], a4, o3);
              delete t12.faces;
            }
            return i3.animate.apply(this, arguments);
          }, s3.attr(t11);
        }
        function o2(t11, e3) {
          let i3 = new tY.types[t11](this, "g");
          return i3.initArgs(e3), i3;
        }
        function r2(t11) {
          return this.element3d("cuboid", t11);
        }
        function h2(t11) {
          let e3 = t11.x || 0, i3 = t11.y || 0, s3 = t11.z || 0, a3 = t11.height || 0, o3 = t11.width || 0, r3 = t11.depth || 0, h3 = tO[this.chartIndex], n3 = h3.options.chart.options3d.alpha, l3 = [], p2, c2 = 0, d2 = [{ x: e3, y: i3, z: s3 }, { x: e3 + o3, y: i3, z: s3 }, { x: e3 + o3, y: i3 + a3, z: s3 }, { x: e3, y: i3 + a3, z: s3 }, { x: e3, y: i3 + a3, z: s3 + r3 }, { x: e3 + o3, y: i3 + a3, z: s3 + r3 }, { x: e3 + o3, y: i3, z: s3 + r3 }, { x: e3, y: i3, z: s3 + r3 }];
          d2 = tE(d2, h3, t11.insidePlotArea);
          let x2 = (t12) => 0 === a3 && t12 > 1 && t12 < 6 ? { x: d2[t12].x, y: d2[t12].y + 10, z: d2[t12].z } : d2[0].x === d2[7].x && t12 >= 4 ? { x: d2[t12].x + 10, y: d2[t12].y, z: d2[t12].z } : 0 === r3 && t12 < 2 || t12 > 5 ? { x: d2[t12].x, y: d2[t12].y, z: d2[t12].z + 10 } : d2[t12], y2 = (t12) => d2[t12], f2 = (t12, e4, i4) => {
            let s4 = t12.map(y2), a4 = e4.map(y2), o4 = t12.map(x2), r4 = e4.map(x2), h4 = [[], -1];
            return 0 > tF(s4) ? h4 = [s4, 0] : 0 > tF(a4) ? h4 = [a4, 1] : i4 && (l3.push(i4), h4 = 0 > tF(o4) ? [s4, 0] : 0 > tF(r4) ? [a4, 1] : [s4, 0]), h4;
          }, u2 = (p2 = f2([3, 2, 1, 0], [7, 6, 5, 4], "front"))[0], z2 = p2[1], g2 = (p2 = f2([1, 6, 7, 0], [4, 5, 2, 3], "top"))[0], b2 = p2[1], m2 = (p2 = f2([1, 2, 5, 6], [0, 7, 4, 3], "side"))[0], v2 = p2[1];
          return 1 === v2 ? c2 += 1e6 * (h3.plotWidth - e3) : v2 || (c2 += 1e6 * e3), c2 += 10 * (!b2 || n3 >= 0 && n3 <= 180 || n3 < 360 && n3 > 357.5 ? h3.plotHeight - i3 : 10 + i3), 1 === z2 ? c2 += 100 * s3 : z2 || (c2 += 100 * (1e3 - s3)), { front: this.toLinePath(u2, true), top: this.toLinePath(g2, true), side: this.toLinePath(m2, true), zIndexes: { group: Math.round(c2) }, forcedSides: l3, isFront: z2, isTop: b2 };
        }
        function n2(t11) {
          let e3 = this.g(), i3 = this.Element.prototype, s3 = ["alpha", "beta", "x", "y", "r", "innerR", "start", "end", "depth"];
          function a3(t12) {
            let e4, i4 = {};
            for (e4 in t12 = tB(t12)) -1 !== s3.indexOf(e4) && (i4[e4] = t12[e4], delete t12[e4]);
            return !!Object.keys(i4).length && [i4, t12];
          }
          for (let i4 of ((t11 = tB(t11)).alpha = (t11.alpha || 0) * tR, t11.beta = (t11.beta || 0) * tR, e3.top = this.path(), e3.side1 = this.path(), e3.side2 = this.path(), e3.inn = this.path(), e3.out = this.path(), e3.onAdd = function() {
            let t12 = e3.parentGroup, i5 = e3.attr("class");
            for (let s4 of (e3.top.add(e3), ["out", "inn", "side1", "side2"])) e3[s4].attr({ class: i5 + " highcharts-3d-side" }).add(t12);
          }, ["addClass", "removeClass"])) e3[i4] = function() {
            let t12 = arguments;
            for (let s4 of ["top", "out", "inn", "side1", "side2"]) e3[s4][i4].apply(e3[s4], t12);
          };
          for (let i4 of (e3.setPaths = function(t12) {
            let i5 = e3.renderer.arc3dPath(t12), s4 = 100 * i5.zTop;
            e3.attribs = t12, e3.top.attr({ d: i5.top, zIndex: i5.zTop }), e3.inn.attr({ d: i5.inn, zIndex: i5.zInn }), e3.out.attr({ d: i5.out, zIndex: i5.zOut }), e3.side1.attr({ d: i5.side1, zIndex: i5.zSide1 }), e3.side2.attr({ d: i5.side2, zIndex: i5.zSide2 }), e3.zIndex = s4, e3.attr({ zIndex: s4 }), t12.center && (e3.top.setRadialReference(t12.center), delete t12.center);
          }, e3.setPaths(t11), e3.fillSetter = function(t12) {
            let e4 = tC(t12).brighten(-0.1).get();
            return this.fill = t12, this.side1.attr({ fill: e4 }), this.side2.attr({ fill: e4 }), this.inn.attr({ fill: e4 }), this.out.attr({ fill: e4 }), this.top.attr({ fill: t12 }), this;
          }, ["opacity", "translateX", "translateY", "visibility"])) e3[i4 + "Setter"] = function(t12, i5) {
            for (let s4 of (e3[i5] = t12, ["out", "inn", "side1", "side2", "top"])) e3[s4].attr(i5, t12);
          };
          return e3.attr = function(t12) {
            if ("object" == typeof t12) {
              let i4 = a3(t12);
              if (i4) {
                let t13 = i4[0];
                arguments[0] = i4[1], void 0 !== t13.alpha && (t13.alpha *= tR), void 0 !== t13.beta && (t13.beta *= tR), t_(e3.attribs, t13), e3.attribs && e3.setPaths(e3.attribs);
              }
            }
            return i3.attr.apply(e3, arguments);
          }, e3.animate = function(t12, s4, o3) {
            let r3 = this.attribs, h3 = "data-" + Math.random().toString(26).substring(2, 9);
            delete t12.center, delete t12.z;
            let n3 = tZ(tG(s4, this.renderer.globalAnimation));
            if (n3.duration) {
              let i4 = a3(t12);
              if (e3[h3] = 0, t12[h3] = 1, e3[h3 + "Setter"] = f().noop, i4) {
                let t13 = i4[0], e4 = (e5, i5) => r3[e5] + (tG(t13[e5], r3[e5]) - r3[e5]) * i5;
                n3.step = function(t14, i5) {
                  i5.prop === h3 && i5.elem.setPaths(tB(r3, { x: e4("x", i5.pos), y: e4("y", i5.pos), r: e4("r", i5.pos), innerR: e4("innerR", i5.pos), start: e4("start", i5.pos), end: e4("end", i5.pos), depth: e4("depth", i5.pos) }));
                };
              }
              s4 = n3;
            }
            return i3.animate.call(this, t12, s4, o3);
          }, e3.destroy = function() {
            return this.top.destroy(), this.out.destroy(), this.inn.destroy(), this.side1.destroy(), this.side2.destroy(), i3.destroy.call(this);
          }, e3.hide = function() {
            this.top.hide(), this.out.hide(), this.inn.hide(), this.side1.hide(), this.side2.hide();
          }, e3.show = function(t12) {
            this.top.show(t12), this.out.show(t12), this.inn.show(t12), this.side1.show(t12), this.side2.show(t12);
          }, e3;
        }
        function l2(t11) {
          let e3 = t11.x || 0, i3 = t11.y || 0, s3 = t11.start || 0, a3 = (t11.end || 0) - 1e-5, o3 = t11.r || 0, r3 = t11.innerR || 0, h3 = t11.depth || 0, n3 = t11.alpha || 0, l3 = t11.beta || 0, p2 = Math.cos(s3), c2 = Math.sin(s3), d2 = Math.cos(a3), x2 = Math.sin(a3), y2 = o3 * Math.cos(l3), f2 = o3 * Math.cos(n3), u2 = r3 * Math.cos(l3), z2 = r3 * Math.cos(n3), g2 = h3 * Math.sin(l3), b2 = h3 * Math.sin(n3), m2 = [["M", e3 + y2 * p2, i3 + f2 * c2]];
          (m2 = m2.concat(tV(e3, i3, y2, f2, s3, a3, 0, 0))).push(["L", e3 + u2 * d2, i3 + z2 * x2]), (m2 = m2.concat(tV(e3, i3, u2, z2, a3, s3, 0, 0))).push(["Z"]);
          let v2 = l3 > 0 ? Math.PI / 2 : 0, M2 = n3 > 0 ? 0 : Math.PI / 2, A2 = s3 > -v2 ? s3 : a3 > -v2 ? -v2 : s3, P2 = a3 < tU - M2 ? a3 : s3 < tU - M2 ? tU - M2 : a3, k2 = 2 * tU - M2, S2 = [["M", e3 + y2 * tj(A2), i3 + f2 * tN(A2)]];
          S2 = S2.concat(tV(e3, i3, y2, f2, A2, P2, 0, 0)), a3 > k2 && s3 < k2 ? (S2.push(["L", e3 + y2 * tj(P2) + g2, i3 + f2 * tN(P2) + b2]), (S2 = S2.concat(tV(e3, i3, y2, f2, P2, k2, g2, b2))).push(["L", e3 + y2 * tj(k2), i3 + f2 * tN(k2)]), (S2 = S2.concat(tV(e3, i3, y2, f2, k2, a3, 0, 0))).push(["L", e3 + y2 * tj(a3) + g2, i3 + f2 * tN(a3) + b2]), (S2 = S2.concat(tV(e3, i3, y2, f2, a3, k2, g2, b2))).push(["L", e3 + y2 * tj(k2), i3 + f2 * tN(k2)]), S2 = S2.concat(tV(e3, i3, y2, f2, k2, P2, 0, 0))) : a3 > tU - M2 && s3 < tU - M2 && (S2.push(["L", e3 + y2 * Math.cos(P2) + g2, i3 + f2 * Math.sin(P2) + b2]), (S2 = S2.concat(tV(e3, i3, y2, f2, P2, a3, g2, b2))).push(["L", e3 + y2 * Math.cos(a3), i3 + f2 * Math.sin(a3)]), S2 = S2.concat(tV(e3, i3, y2, f2, a3, P2, 0, 0))), S2.push(["L", e3 + y2 * Math.cos(P2) + g2, i3 + f2 * Math.sin(P2) + b2]), (S2 = S2.concat(tV(e3, i3, y2, f2, P2, A2, g2, b2))).push(["Z"]);
          let w2 = [["M", e3 + u2 * p2, i3 + z2 * c2]];
          (w2 = w2.concat(tV(e3, i3, u2, z2, s3, a3, 0, 0))).push(["L", e3 + u2 * Math.cos(a3) + g2, i3 + z2 * Math.sin(a3) + b2]), (w2 = w2.concat(tV(e3, i3, u2, z2, a3, s3, g2, b2))).push(["Z"]);
          let D2 = [["M", e3 + y2 * p2, i3 + f2 * c2], ["L", e3 + y2 * p2 + g2, i3 + f2 * c2 + b2], ["L", e3 + u2 * p2 + g2, i3 + z2 * c2 + b2], ["L", e3 + u2 * p2, i3 + z2 * c2], ["Z"]], L2 = [["M", e3 + y2 * d2, i3 + f2 * x2], ["L", e3 + y2 * d2 + g2, i3 + f2 * x2 + b2], ["L", e3 + u2 * d2 + g2, i3 + z2 * x2 + b2], ["L", e3 + u2 * d2, i3 + z2 * x2], ["Z"]], I2 = Math.atan2(b2, -g2), T2 = Math.abs(a3 + I2), X2 = Math.abs(s3 + I2), H2 = Math.abs((s3 + a3) / 2 + I2);
          function Y2(t12) {
            return (t12 %= 2 * Math.PI) > Math.PI && (t12 = 2 * Math.PI - t12), t12;
          }
          T2 = Y2(T2), X2 = Y2(X2);
          let Z2 = 1e5 * (H2 = Y2(H2)), C2 = 1e5 * X2, O2 = 1e5 * T2;
          return { top: m2, zTop: 1e5 * Math.PI + 1, out: S2, zOut: Math.max(Z2, C2, O2), inn: w2, zInn: Math.max(Z2, C2, O2), side1: D2, zSide1: 0.99 * O2, side2: L2, zSide2: 0.99 * C2 };
        }
        t10.compose = function(t11) {
          let p2 = t11.prototype;
          p2.element3d || t_(p2, { Element3D: tY, arc3d: n2, arc3dPath: l2, cuboid: r2, cuboidPath: h2, element3d: o2, face3d: s2, polyhedron: a2, toLinePath: e2, toLineSegments: i2 });
        };
      }(l || (l = {}));
      let tJ = l;
      var tK = d(532), tQ = d.n(tK);
      let { defaultOptions: t$ } = f(), { addEvent: t0, merge: t1, pick: t3, splat: t2 } = f();
      function t5(t10) {
        return new t9(this, t10);
      }
      function t6() {
        let t10 = this.options.zAxis = t2(this.options.zAxis || {});
        this.is3d() && (this.zAxis = [], t10.forEach((t11) => {
          this.addZAxis(t11).setScale();
        }));
      }
      class t9 extends tQ() {
        constructor() {
          super(...arguments), this.isZAxis = true;
        }
        static compose(t10) {
          let e2 = t10.prototype;
          e2.addZAxis || (t$.zAxis = t1(t$.xAxis, { offset: 0, lineWidth: 0 }), e2.addZAxis = t5, e2.collectionsWithInit.zAxis = [e2.addZAxis], e2.collectionsWithUpdate.push("zAxis"), t0(t10, "afterCreateAxes", t6));
        }
        init(t10, e2) {
          this.isZAxis = true, super.init(t10, e2, "zAxis");
        }
        getSeriesExtremes() {
          this.hasVisibleSeries = false, this.dataMin = this.dataMax = this.ignoreMinPadding = this.ignoreMaxPadding = void 0, this.stacking && this.stacking.buildStacks(), this.series.forEach((t10) => {
            if (t10.reserveSpace()) {
              let e2 = t10.options.threshold;
              this.hasVisibleSeries = true, this.positiveValuesOnly && e2 <= 0 && (e2 = void 0);
              let i2 = t10.getColumn("z");
              i2.length && (this.dataMin = Math.min(t3(this.dataMin, i2[0]), Math.min.apply(null, i2)), this.dataMax = Math.max(t3(this.dataMax, i2[0]), Math.max.apply(null, i2)));
            }
          });
        }
        setAxisSize() {
          var _a;
          let t10 = this.chart;
          super.setAxisSize(), this.width = this.len = ((_a = t10.options.chart.options3d) == null ? void 0 : _a.depth) || 0, this.right = t10.chartWidth - this.width - this.left;
        }
      }
      let { composed: t4 } = f(), { perspective: t7 } = A, { addEvent: t8, extend: et, pick: ee, pushUnique: ei, wrap: es } = f();
      function ea() {
        let t10 = this.chart, e2 = this.options, i2 = e2.depth, s2 = (e2.stacking ? e2.stack || 0 : this.index) * (i2 + (e2.groupZPadding || 1)), a2 = this.borderWidth % 2 ? 0.5 : 0, o2;
        for (let r2 of (t10.inverted && !this.yAxis.reversed && (a2 *= -1), false !== e2.grouping && (s2 = 0), s2 += e2.groupZPadding || 1, this.points)) if (r2.outside3dPlot = null, null !== r2.y) {
          let e3, h2 = et({ x: 0, y: 0, width: 0, height: 0 }, r2.shapeArgs || {}), n2 = [["x", "width"], ["y", "height"]], l2 = r2.tooltipPos;
          for (let t11 of n2) if ((e3 = h2[t11[0]] - a2) < 0 && (h2[t11[1]] += h2[t11[0]] + a2, h2[t11[0]] = -a2, e3 = 0), e3 + h2[t11[1]] > this[t11[0] + "Axis"].len && 0 !== h2[t11[1]] && (h2[t11[1]] = this[t11[0] + "Axis"].len - h2[t11[0]]), 0 !== h2[t11[1]] && (h2[t11[0]] >= this[t11[0] + "Axis"].len || h2[t11[0]] + h2[t11[1]] <= a2)) {
            for (let t12 in h2) h2[t12] = "y" === t12 ? -9999 : 0;
            r2.outside3dPlot = true;
          }
          if ("roundedRect" === r2.shapeType && (r2.shapeType = "cuboid"), r2.shapeArgs = et(h2, { z: s2, depth: i2, insidePlotArea: true }), o2 = { x: h2.x + h2.width / 2, y: h2.y, z: s2 + i2 / 2 }, t10.inverted && (o2.x = h2.height, o2.y = r2.clientX || 0), r2.axisXpos = o2.x, r2.axisYpos = o2.y, r2.axisZpos = o2.z, r2.plot3d = t7([o2], t10, true, false)[0], l2) {
            let e4 = t7([{ x: l2[0], y: l2[1], z: s2 + i2 / 2 }], t10, true, false)[0];
            r2.tooltipPos = [e4.x, e4.y];
          }
        }
        this.z = s2;
      }
      function eo() {
        if (this.chart.is3d()) {
          let i2 = this.options, s2 = i2.grouping, a2 = i2.stacking, o2 = this.yAxis.options.reversedStacks, r2 = 0;
          if (!(void 0 !== s2 && !s2)) {
            var t10, e2;
            let s3, h2, n2, l2, p2, c2 = (t10 = this.chart, e2 = a2 || void 0, h2 = t10.series, n2 = { totalStacks: 0 }, p2 = 1, h2.forEach(function(t11) {
              n2[l2 = ee(t11.options.stack, e2 ? 0 : h2.length - 1 - t11.index)] ? n2[l2].series.push(t11) : (n2[l2] = { series: [t11], position: p2 }, p2++);
            }), n2.totalStacks = p2 + 1, n2), d2 = i2.stack || 0;
            for (s3 = 0; s3 < c2[d2].series.length && c2[d2].series[s3] !== this; s3++) ;
            r2 = 10 * (c2.totalStacks - c2[d2].position) + (o2 ? s3 : -s3), this.xAxis.reversed || (r2 = 10 * c2.totalStacks - r2);
          }
          i2.depth = i2.depth || 25, this.z = this.z || 0, i2.zIndex = r2;
        }
      }
      function er(t10, ...e2) {
        return this.series.chart.is3d() ? this.graphic && "g" !== this.graphic.element.nodeName : t10.apply(this, e2);
      }
      function eh(t10) {
        if (this.chart.is3d()) {
          let t11 = arguments, e2 = t11[1], i2 = this.yAxis, s2 = this.yAxis.reversed;
          if (e2) for (let t12 of this.points) null !== t12.y && (t12.height = t12.shapeArgs.height, t12.shapey = t12.shapeArgs.y, t12.shapeArgs.height = 1, s2 || (t12.stackY ? t12.shapeArgs.y = t12.plotY + i2.translate(t12.stackY) : t12.shapeArgs.y = t12.plotY + (t12.negative ? -t12.height : t12.height)));
          else {
            for (let t12 of this.points) null !== t12.y && (t12.shapeArgs.height = t12.height, t12.shapeArgs.y = t12.shapey, t12.graphic && t12.graphic[t12.outside3dPlot ? "attr" : "animate"](t12.shapeArgs, this.options.animation));
            this.drawDataLabels();
          }
        } else t10.apply(this, [].slice.call(arguments, 1));
      }
      function en(t10, e2, i2, s2, a2, o2) {
        return "dataLabelsGroup" !== e2 && "markerGroup" !== e2 && this.chart.is3d() && (this[e2] && delete this[e2], o2 && (this.chart.columnGroup || (this.chart.columnGroup = this.chart.renderer.g("columnGroup").add(o2)), this[e2] = this.chart.columnGroup, this.chart.columnGroup.attr(this.getPlotBox()), this[e2].survive = true, "group" === e2 && (arguments[3] = "visible"))), t10.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      function el(t10) {
        let e2 = t10.apply(this, [].slice.call(arguments, 1));
        return this.chart.is3d && this.chart.is3d() && (e2.stroke = this.options.edgeColor || e2.fill, e2["stroke-width"] = ee(this.options.edgeWidth, 1)), e2;
      }
      function ep(t10, e2, i2) {
        let s2 = this.chart.is3d && this.chart.is3d();
        s2 && (this.options.inactiveOtherPoints = true), t10.call(this, e2, i2), s2 && (this.options.inactiveOtherPoints = false);
      }
      function ec(t10, e2) {
        if (this.chart.is3d()) for (let t11 of this.points) t11.visible = t11.options.visible = e2 = void 0 === e2 ? !ee(this.visible, t11.visible) : e2, this.options.data[this.data.indexOf(t11)] = t11.options, t11.graphic && t11.graphic.attr({ visibility: e2 ? "visible" : "hidden" });
        t10.apply(this, Array.prototype.slice.call(arguments, 1));
      }
      function ed(t10) {
        t10.apply(this, [].slice.call(arguments, 1)), this.chart.is3d() && this.translate3dShapes();
      }
      function ex(t10, e2, i2, s2, a2) {
        let o2 = this.chart;
        if (s2.outside3dPlot = e2.outside3dPlot, o2.is3d() && this.is("column")) {
          let t11 = this.options, i3 = ee(s2.inside, !!this.options.stacking), r2 = o2.options.chart.options3d, h2 = e2.pointWidth / 2 || 0, n2 = { x: a2.x + h2, y: a2.y, z: this.z + t11.depth / 2 };
          o2.inverted && (i3 && (a2.width = 0, n2.x += e2.shapeArgs.height / 2), r2.alpha >= 90 && r2.alpha <= 270 && (n2.y += e2.shapeArgs.width)), a2.x = (n2 = t7([n2], o2, true, false)[0]).x - h2, a2.y = e2.outside3dPlot ? -9e9 : n2.y;
        }
        t10.apply(this, [].slice.call(arguments, 1));
      }
      function ey(t10) {
        return !arguments[2].outside3dPlot && t10.apply(this, [].slice.call(arguments, 1));
      }
      function ef(t10, e2) {
        let i2 = t10.apply(this, [].slice.call(arguments, 1)), s2 = this.axis.chart, { width: a2 } = e2;
        if (s2.is3d() && this.base) {
          let t11 = +this.base.split(",")[0], e3 = s2.series[t11], o2 = s2.options.chart.options3d;
          if (e3 && "column" === e3.type) {
            let t12 = { x: i2.x + (s2.inverted ? i2.height : a2 / 2), y: i2.y, z: e3.options.depth / 2 };
            s2.inverted && (i2.width = 0, o2.alpha >= 90 && o2.alpha <= 270 && (t12.y += a2)), i2.x = (t12 = t7([t12], s2, true, false)[0]).x - a2 / 2, i2.y = t12.y;
          }
        }
        return i2;
      }
      let { pie: { prototype: { pointClass: eu } } } = Z().seriesTypes, ez = class extends eu {
        haloPath() {
          var _a;
          return ((_a = this.series) == null ? void 0 : _a.chart.is3d()) ? [] : super.haloPath.apply(this, arguments);
        }
      }, { composed: eg, deg2rad: eb } = f(), { pie: em } = Z().seriesTypes, { extend: ev, pick: eM, pushUnique: eA } = f();
      class eP extends em {
        static compose(t10) {
          eA(eg, "Pie3D") && (t10.types.pie = eP);
        }
        addPoint() {
          super.addPoint.apply(this, arguments), this.chart.is3d() && this.update(this.userOptions, true);
        }
        animate(t10) {
          if (this.chart.is3d()) {
            let e2 = this.center, i2 = this.group, s2 = this.markerGroup, a2 = this.options.animation, o2;
            true === a2 && (a2 = {}), t10 ? (i2.oldtranslateX = eM(i2.oldtranslateX, i2.translateX), i2.oldtranslateY = eM(i2.oldtranslateY, i2.translateY), o2 = { translateX: e2[0], translateY: e2[1], scaleX: 1e-3, scaleY: 1e-3 }, i2.attr(o2), s2 && (s2.attrSetters = i2.attrSetters, s2.attr(o2))) : (o2 = { translateX: i2.oldtranslateX, translateY: i2.oldtranslateY, scaleX: 1, scaleY: 1 }, i2.animate(o2, a2), s2 && s2.animate(o2, a2));
          } else super.animate.apply(this, arguments);
        }
        getDataLabelPosition(t10, e2) {
          let i2 = super.getDataLabelPosition(t10, e2);
          if (this.chart.is3d()) {
            let e3 = this.chart.options.chart.options3d, s2 = t10.shapeArgs, a2 = s2.r, o2 = (s2.alpha || (e3 == null ? void 0 : e3.alpha)) * eb, r2 = (s2.beta || (e3 == null ? void 0 : e3.beta)) * eb, h2 = (s2.start + s2.end) / 2, n2 = i2.connectorPosition, l2 = -a2 * (1 - Math.cos(o2)) * Math.sin(h2), p2 = a2 * (Math.cos(r2) - 1) * Math.cos(h2);
            for (let t11 of [i2 == null ? void 0 : i2.natural, n2.breakAt, n2.touchingSliceAt]) t11.x += p2, t11.y += l2;
          }
          return i2;
        }
        pointAttribs(t10) {
          let e2 = super.pointAttribs.apply(this, arguments), i2 = this.options;
          return this.chart.is3d() && !this.chart.styledMode && (e2.stroke = i2.edgeColor || t10.color || this.color, e2["stroke-width"] = eM(i2.edgeWidth, 1)), e2;
        }
        translate() {
          if (super.translate.apply(this, arguments), !this.chart.is3d()) return;
          let t10 = this.options, e2 = t10.depth || 0, i2 = this.chart.options.chart.options3d, s2 = i2.alpha, a2 = i2.beta, o2 = t10.stacking ? (t10.stack || 0) * e2 : this._i * e2;
          for (let i3 of (o2 += e2 / 2, false !== t10.grouping && (o2 = 0), this.points)) {
            let r2 = i3.shapeArgs;
            i3.shapeType = "arc3d", r2.z = o2, r2.depth = 0.75 * e2, r2.alpha = s2, r2.beta = a2, r2.center = this.center;
            let h2 = (r2.end + r2.start) / 2;
            i3.slicedTranslation = { translateX: Math.round(Math.cos(h2) * t10.slicedOffset * Math.cos(s2 * eb)), translateY: Math.round(Math.sin(h2) * t10.slicedOffset * Math.cos(s2 * eb)) };
          }
        }
        drawTracker() {
          if (super.drawTracker.apply(this, arguments), this.chart.is3d()) {
            for (let t10 of this.points) if (t10.graphic) for (let e2 of ["out", "inn", "side1", "side2"]) t10.graphic && (t10.graphic[e2].element.point = t10);
          }
        }
      }
      ev(eP.prototype, { pointClass: ez });
      var ek = d(632), eS = d.n(ek);
      let { pointClass: ew } = eS().prototype, { defined: eD } = f(), eL = class extends ew {
        applyOptions() {
          return super.applyOptions.apply(this, arguments), eD(this.z) || (this.z = 0), this;
        }
      }, { pointCameraDistance: eI } = A, { extend: eT, merge: eX } = f();
      class eH extends eS() {
        pointAttribs(t10) {
          let e2 = super.pointAttribs.apply(this, arguments);
          return this.chart.is3d() && t10 && (e2.zIndex = eI(t10, this.chart)), e2;
        }
      }
      eH.defaultOptions = eX(eS().defaultOptions, { tooltip: { pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>" } }), eT(eH.prototype, { axisTypes: ["xAxis", "yAxis", "zAxis"], directTouch: true, parallelArrays: ["x", "y", "z"], pointArrayMap: ["x", "y", "z"], pointClass: eL }), Z().registerSeriesType("scatter3d", eH);
      let eY = f();
      ({ compose: function(t10) {
        E(C, "Area3DSeries") && F(t10.prototype, "getGraphPath", W);
      } }).compose(eY.Series.types.area), ty.compose(eY.Axis, eY.Tick), H.compose(eY.Chart, eY.Fx), { compose: function(t10, e2) {
        if (ei(t4, "Column3D")) {
          let i2 = t10.prototype, s2 = e2.prototype, { column: a2, columnRange: o2 } = t10.types;
          if (es(i2, "alignDataLabel", ex), es(i2, "justifyDataLabel", ey), es(s2, "getStackBox", ef), a2) {
            let t11 = a2.prototype, e3 = t11.pointClass.prototype;
            t11.translate3dPoints = () => void 0, t11.translate3dShapes = ea, t8(t11, "afterInit", eo), es(e3, "hasNewShapeType", er), es(t11, "animate", eh), es(t11, "plotGroup", en), es(t11, "pointAttribs", el), es(t11, "setState", ep), es(t11, "setVisible", ec), es(t11, "translate", ed);
          }
          if (o2) {
            let t11 = o2.prototype;
            es(t11.pointClass.prototype, "hasNewShapeType", er), es(t11, "plotGroup", en), es(t11, "pointAttribs", el), es(t11, "setState", ep), es(t11, "setVisible", ec);
          }
        }
      } }.compose(eY.Series, tL()), eP.compose(eY.Series), tw.compose(eY.Series), tJ.compose(tu().getRendererType()), t9.compose(eY.Chart);
      let eZ = eY;
      return x.default;
    })());
  }
});
export default require_highcharts_3d();
//# sourceMappingURL=highcharts_highcharts-3d.js.map
